import aerosandbox
import abc


class CreateFlightVehicle:
    """
    Factory method which generates an aerosandbox `airplane` object.
    Requires a geometric inputs dictionary which can be generated by
    the CoSApp system `GenerateAeroGeom` from the design discipline
    """

    def __init__(
        self, aero_geom=None, nacelles_enabled=False, generate_airfoil_polars=True
    ):
        self.ag = aero_geom
        self.nacelles_enabled = nacelles_enabled
        self.generate_airfoil_polars = generate_airfoil_polars
        self.airfoils_generated = False

    @abc.abstractmethod
    def generate(self):
        pass

    @abc.abstractmethod
    def update(self):
        pass


class CreateAirplane(CreateFlightVehicle):
    def __generate_airfoil(self, airfoil_name: str):
        """
        This private method generates the polars for each of the airfoils using Xfoil
        """
        airfoil = aerosandbox.Airfoil(airfoil_name)

        if self.generate_airfoil_polars is True:
            airfoil.generate_polars(
                cache_filename=f"amad/disciplines/aerodynamics/temp/{airfoil_name}.json"
            )
        return airfoil

    def __generate_fuselage(self):
        """
        This private method generates the fuselage sections from the input geometry
        """

        try:
            self.airplane_fuselages = [
                aerosandbox.Fuselage(
                    name="Fuselage",
                    xsecs=[
                        aerosandbox.FuselageXSec(
                            xyz_c=[fsec[0], fsec[1], fsec[2]], radius=fsec[3]
                        )
                        for fsec in fuse_no
                    ],
                )
                for fuse_no in self.ag["fuse_def"]
            ]

        except TypeError:
            self.airplane_fuselages = []

    def __generate_nacelles(self):
        """
        This private method generates the nacelles from the input geometry
        """

        self.airplane_nacelles = [
            aerosandbox.Fuselage(
                name="Nacelle",
                xsecs=[
                    aerosandbox.FuselageXSec(
                        xyz_c=[nsec[0], nsec[1], nsec[2]], radius=nsec[3]
                    )
                    for nsec in self.ag["nacelle_def"]
                ],
            ).translate(nacelle_no)
            for nacelle_no in self.ag["nacelle_xyz"]
        ]

    def __generate_wings(self):
        """
        This private method generates the wing and control surface sections from the input geometry
        """

        # Create all wing and ctrl surface sections
        wing_sections = [
            aerosandbox.WingXSec(
                xyz_le=self.ag["x_wing_xyz"][sect],
                chord=self.ag["wing_chords"][sect],
                twist=self.ag["wing_twists"][sect],
                airfoil=self.wing_airfoils[sect],
            )
            for sect in range(0, self.ag["n_wing_sections"])
        ]

        vtail_sections = [
            aerosandbox.WingXSec(
                xyz_le=self.ag["x_vtail_xyz"][sect],
                chord=self.ag["vtail_chords"][sect],
                twist=self.ag["vtail_twists"][sect],
                airfoil=self.vtail_airfoils[sect],
            )
            for sect in range(0, self.ag["n_vtail_sections"])
        ]

        htail_sections = [
            aerosandbox.WingXSec(
                xyz_le=self.ag["x_htail_xyz"][sect],
                chord=self.ag["htail_chords"][sect],
                twist=self.ag["htail_twists"][sect],
                airfoil=self.htail_airfoils[sect],
            )
            for sect in range(0, self.ag["n_htail_sections"])
        ]

        canard_sections = [
            aerosandbox.WingXSec(
                xyz_le=self.ag["x_canard_xyz"][sect],
                chord=self.ag["canard_chords"][sect],
                twist=self.ag["canard_twists"][sect],
                airfoil=self.canard_airfoils[sect],
            )
            for sect in range(0, self.ag["n_canard_sections"])
        ]

        # Compile wing and control surfaces into a big list
        self.airplane_wings = [
            aerosandbox.Wing(
                name="Main Wing", symmetric=True, xsecs=wing_sections
            ).translate(self.ag["x_wing_disp"])
        ]

        if len(htail_sections) > 0:
            self.airplane_wings.append(
                aerosandbox.Wing(
                    name="Horizontal Stabilizer", symmetric=True, xsecs=htail_sections
                ).translate(self.ag["x_htail_disp"])
            )

        if len(vtail_sections) > 0:
            self.airplane_wings.append(
                aerosandbox.Wing(
                    name="Vertical Stabilizer", symmetric=False, xsecs=vtail_sections
                ).translate(self.ag["x_vtail_disp"])
            )

        if len(canard_sections) > 0:
            self.airplane_wings.append(
                aerosandbox.Wing(
                    name="Canard", symmetric=True, xsecs=canard_sections
                ).translate(self.ag["x_canard_disp"])
            )

    def __calculate_MAC(self):
        self.x_MAC = self.airplane_wings[0].mean_aerodynamic_chord()
        self.x_aero_center = self.airplane_wings[0].aerodynamic_center()

    def generate_all_airfoils(self):
        # generate wing and control surface airfoils
        self.wing_airfoils = [
            self.__generate_airfoil(airfoil) for airfoil in self.ag["wing_airfoils"]
        ]
        self.vtail_airfoils = [
            self.__generate_airfoil(airfoil) for airfoil in self.ag["vtail_airfoils"]
        ]
        self.htail_airfoils = [
            self.__generate_airfoil(airfoil) for airfoil in self.ag["htail_airfoils"]
        ]
        self.canard_airfoils = [
            self.__generate_airfoil(airfoil) for airfoil in self.ag["canard_airfoils"]
        ]

        self.airfoils_generated = True

    def generate(self):
        """
        The `generate` method creates an AeroSandBox airplane object from the input geometry
        """

        if self.airfoils_generated is False:
            self.generate_all_airfoils()

        self.__generate_fuselage()
        self.__generate_wings()
        self.__calculate_MAC()

        if self.nacelles_enabled:
            self.__generate_nacelles()
            fuselages = self.airplane_fuselages + self.airplane_nacelles
        else:
            fuselages = self.airplane_fuselages

        self.airplane = aerosandbox.Airplane(
            name=self.ag["ac_name"],
            xyz_ref=[self.x_aero_center[0], 0, 0],  # CG location
            wings=self.airplane_wings,
            fuselages=fuselages,
        )

    def update(self, latest_geom=None):
        """
        The `update` method removes the existing wings (and control surfaces) and replaces them.
        For the time being, the fuselage is untouched.
        """

        # update to the latest geometry
        if latest_geom is not None:
            self.ag = latest_geom

        # remove old rusty wings
        self.airplane.wings.clear()

        # add new shiny ones
        self.__generate_wings()
        self.__calculate_MAC()
        self.airplane.wings = self.airplane_wings

        # update CG
        self.airplane.xyz_ref = [self.x_aero_center[0], 0, 0]

    def output(self):
        self.generate()
        return self.airplane
